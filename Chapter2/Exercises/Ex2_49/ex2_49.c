/**
 * @file ex2_49.c
 * @author Felix Lempriere
 * @brief Solution to Exercise 2-49 from Chapter 2 of Sedgewick's Algorithms in
 * C.
 *
 * This program generates M random integers and stores them in an array, then
 * counts the number of N random integers that match one of the numbers in the
 * array using sequential search. The program is run for various values of M
 * and N (10, 100, 1000, 10000, 100000).
 *
 * The program allows experimentation with different typedefs for the key type
 * and corresponding maximum key values (KEY_MAX). The results are displayed in
 * a tabular format, showing the values of M, N, and the number of matches.
 *
 * @date 2025-04-07
 * @version 0.1
 * @copyright Copyright (c) 2025
 */
#include "MacroLibrary/Random.h"

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

/**
 * @brief Maximum number of random integers to store
 *
 */
constexpr size_t MAX_M = 100000u;
/**
 * @brief Number of test cases to generate.
 *
 */
constexpr size_t CASES = 5u;

/**
 * @brief Array key values
 *
 */
typedef uint16_t key;

/**
 * @brief Largest valid key value
 *
 */
constexpr key KEY_MAX = UINT16_MAX;

/**
 * @brief Generates a random key value within the range [0, KEY_MAX).
 *
 * This function utilizes the random number generator to produce a
 * uniformly distributed random integer of type `key`.
 *
 * @return key A random key value within the specified range.
 */
static inline key rand_key(void);

/**
 * @brief Populates the given array with random integers.
 *
 * This function fills the provided array `a` of length `len` with random
 * integers uniformly distributed in the range [0, KEY_MAX). Each element
 * of the array is assigned a random value generated by the `rand_key`
 * function.
 *
 * @param len The length of the array to be filled.
 * @param a The array to be populated with random integers.
 *
 * @pre The array indices [0, len) are valid in the array a.
 * @post The indices [0, len) are initialised.
 *
 * @see KEY_MAX
 * @see rand_key
 */
void fill_array(size_t const len, key a[const static len]);

/**
 * @brief Counts the number of random integers that match elements in an array.
 *
 * This function generates `n` random integers and checks how many of them
 * are present in the array `a` of size `m`. The function uses sequential
 * search to determine if each random integer is contained in the array.
 *
 * @param n The number of random integers to generate and test.
 * @param m The size of the array `a` to search within.
 * @param a The array of `m` elements to be searched.
 *
 * @pre the indices [0, m) are valid for the array a.
 *
 * @return size_t The number of random integers that match elements in the
 * array.
 *
 * @see rand_key
 * @see search
 */
size_t countMatches(size_t const n, size_t const m,
                    key const a[const static m]);

/**
 * @brief Value representing a value not in search
 *
 */
constexpr size_t NOT_FOUND = SIZE_MAX;

/**
 * @brief Performs a sequential search to find the index of a target value in an
 * array.
 *
 * @details
 * This function searches for the target value `v` within the array `a` starting
 * from index `l` (inclusive) to index `r` (inclusive). It iterates through the
 * array elements one by one and returns the index of the first occurrence of
 * `v` if found. If the value is not found within the specified range, the
 * function returns a predefined constant `NOT_FOUND`.
 *
 * @param a The array to search within. The array must have at least `r + 1`
 * elements to ensure that the search range is valid.
 * @param l The starting index of the search range (inclusive).
 * @param r The ending index of the search range (inclusive).
 * @param v The target value to search for.
 * @return The index of the target value `v` if found, otherwise `NOT_FOUND`.
 *
 * @pre the indices [l, r] are valid for the array a.
 * @pre a is not a nullptr.
 *
 * @post returns index i s.t. a[i] == v or NOT_FOUND if v is not in a[l..r].
 *
 * @see NOT_FOUND A constant representing the value returned when the target is
 * not found.
 */
size_t search(key const v, size_t const l, size_t const r,
              key const a[const static r + 1]);

/**
 * @brief Demonstrates the distribution of randomly generated integers.
 *
 * Specifically, the program iterates over a predefined set of test cases for M
 * (10, 100, 1000, 10000, 100000) and N (10, 100, 1000, 10000, 100000). For each
 * combination of M and N:
 * - An array of size M is populated with random integers.
 * - N random integers are generated, and the number of matches with the array
 *   elements is counted using sequential search.
 * - The results, including the values of M, N, and the number of matches, are
 *   printed in a tabular format.
 *
 * @return EXIT_SUCCESS on successful program completion.
 */
int main(int argc, char* argv[argc + 1]) {
    key random_ints[MAX_M];
    size_t cases[CASES] = { 10, 100, 1000, 10000, 100000 };

    RAND_SEED_TIME;
    for (register size_t i = 0; i < CASES; i++) {    // choose M case
        register size_t m = cases[i];
        fill_array(m, random_ints);

        for (register size_t j = 0; j < CASES; j++) {    // choose N case
            register size_t n = cases[j];
            register size_t matches = countMatches(n, m, random_ints);
            printf("M: %zu, N: %zu, Matches: %zu\n", m, n, matches);
        }
    }
    return EXIT_SUCCESS;
}

size_t search(key const v, size_t l, size_t const r,
              key const a[const static r + 1]) {
    for (; l <= r; l++) {
        if (v == a[l]) return l;
    }
    return NOT_FOUND;
}

size_t countMatches(size_t const n, size_t const m,
                    key const a[const static m]) {
    register size_t matches = 0;
    for (register size_t i = 0; i < n; i++) {
        register key num = rand_key();
        matches += (search(num, 0, m - 1, a) == NOT_FOUND) ? 0 : 1;
    }
    return matches;
}

void fill_array(size_t const len, key a[const static len]) {
    for (register size_t i = 0; i < len; i++) { a[i] = rand_key(); }
}

static inline key rand_key(void) { return CAST(key) RANDUINT(KEY_MAX); }